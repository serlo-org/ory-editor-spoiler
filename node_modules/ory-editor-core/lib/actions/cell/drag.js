'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cancelCellDrag = exports.clearHover = exports.dragCell = exports.cellHoverInlineRight = exports.cellHoverInlineLeft = exports.cellHoverBelow = exports.cellHoverAbove = exports.cellHoverRightOf = exports.cellHoverLeftOf = exports.cellHover = exports.CLEAR_CLEAR_HOVER = exports.CELL_DRAG_CANCEL = exports.CELL_DRAG = exports.CELL_DRAG_HOVER = undefined;

var _const = require('../../const');

var CELL_DRAG_HOVER = exports.CELL_DRAG_HOVER = 'CELL_DRAG_HOVER'; /**
                                                                    * @module src/editor/actions/cell/drag
                                                                    *
                                                                    * awo4tihjaqo4ith
                                                                    */

var CELL_DRAG = exports.CELL_DRAG = 'CELL_DRAG';
var CELL_DRAG_CANCEL = exports.CELL_DRAG_CANCEL = 'CELL_DRAG_CANCEL';
var CLEAR_CLEAR_HOVER = exports.CLEAR_CLEAR_HOVER = 'CLEAR_CLEAR_HOVER';

/**
 * Creates a redux action for when a cell hovers another item.
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHover(drag, hover, level, position))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @param {number} level Set the level if the dragged cells should hover over an ancestor of hover.
 * @param {string} position Can be left, right, above, below.
 * @return {Action}
 */
var cellHover = exports.cellHover = function cellHover(_ref, _ref2) {
  var drag = _ref.id;
  var hover = _ref2.id;
  var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var position = arguments[3];
  return {
    type: CELL_DRAG_HOVER,
    ts: new Date(),
    drag: drag,
    hover: hover,
    level: level,
    position: position
  };
};

/**
 * Creates a redux action for when a cell is hovering another cell on the left.
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHoverLeftOf(drag, hover, level))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @param {number} level Set the level if the dragged cells should hover over an ancestor of hover.
 * @return {Action}
 */
var cellHoverLeftOf = exports.cellHoverLeftOf = function cellHoverLeftOf(drag, hover, level) {
  return cellHover(drag, hover, level, _const.positions.LEFT_OF);
};

/**
 * Creates a redux action for when a cell is hovering another cell on the right.
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHoverRightOf(drag, hover, level))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @param {number} level Set the level if the dragged cells should hover over an ancestor of hover.
 * @return {Action}
 */
var cellHoverRightOf = exports.cellHoverRightOf = function cellHoverRightOf(drag, hover, level) {
  return cellHover(drag, hover, level, _const.positions.RIGHT_OF);
};

/**
 * Creates a redux action for when a cell is hovering another cell above.
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHoverAbove(drag, hover, level))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @param {number} level Set the level if the dragged cells should hover over an ancestor of hover.
 * @return {Action}
 */
var cellHoverAbove = exports.cellHoverAbove = function cellHoverAbove(drag, hover, level) {
  return cellHover(drag, hover, level, _const.positions.ABOVE);
};

/**
 * Creates a redux action for when a cell is hovering another cell below.
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHoverBelow(drag, hover, level))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @param {number} level Set the level if the dragged cells should hover over an ancestor of hover.
 * @return {Action}
 */
var cellHoverBelow = exports.cellHoverBelow = function cellHoverBelow(drag, hover, level) {
  return cellHover(drag, hover, level, _const.positions.BELOW);
};

/**
 * Creates a redux action for when a cell is hovering another cell on the left, but inline (css floating).
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHoverInlineLeft(drag, hover))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @return {Action}
 */
var cellHoverInlineLeft = exports.cellHoverInlineLeft = function cellHoverInlineLeft(drag, hover) {
  return cellHover(drag, hover, 0, _const.positions.INLINE_LEFT);
};

/**
 * Creates a redux action for when a cell is hovering another cell on the right, but inline (css floating).
 *
 * @example
 * // const store = redux.createStore()
 * store.dispatch(cellHoverInlineRight(drag, hover))
 *
 * @param {Cell} drag The cell that is currently being dragged.
 * @param {Cell} hover The cell that is being hovered by the dragged cell.
 * @return {Action}
 */
var cellHoverInlineRight = exports.cellHoverInlineRight = function cellHoverInlineRight(drag, hover) {
  return cellHover(drag, hover, 0, _const.positions.INLINE_RIGHT);
};

/**
 * Creates a redux action for when a cell is being dragged.
 *
 * @example
 * // const store = redux.createStore()
 * // const cell = { id: '1', ... }
 * store.dispatch(dragCell(cell.id))
 *
 * @param {string} id The id of the cell that is being dragged.
 * @return {Action}
 */
var dragCell = exports.dragCell = function dragCell(id) {
  return {
    type: CELL_DRAG,
    ts: new Date(),
    id: id
  };
};

/**
 * Creates a redux action to clear hover state of all cells.
 *
 * @return {Action}
 */
var clearHover = exports.clearHover = function clearHover() {
  return {
    type: CLEAR_CLEAR_HOVER,
    ts: new Date()
  };
};

/**
 * Creates a redux action for when cell dragging ends.
 *
 * @example
 * // const store = redux.createStore()
 * // const cell = { id: '1', ... }
 * store.dispatch(cancelCellDrag(cell.id))
 *
 * @param {string} id
 * @return {Action}
 */
var cancelCellDrag = exports.cancelCellDrag = function cancelCellDrag(id) {
  return {
    type: CELL_DRAG_CANCEL,
    ts: new Date(),
    id: id
  };
};
//# sourceMappingURL=drag.js.map