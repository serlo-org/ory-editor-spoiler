{"version":3,"sources":["../../../../src/reducer/editable/helper/merge.js"],"names":["notSharp","c","mergeRows","state","length","rowB","rowsAcc","rowA","numberOfCells","id","join","cellA","cells","cellB","pluginName","pluginVersion","pluginMerge","content","newCellsAcc","lastRow","splitRows","row","split","map","i","mergeDecorator","action","type","mode"],"mappings":"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","file":"merge.js","sourcesContent":["// @flow'\nimport flatten from 'ramda/src/flatten'\nimport head from 'ramda/src/head'\nimport path from 'ramda/src/path'\nimport map from 'ramda/src/map'\nimport reduce from 'ramda/src/reduce'\nimport tail from 'ramda/src/tail'\nimport takeWhile from 'ramda/src/takeWhile'\n\nimport { SET_DISPLAY_MODE } from '../../../actions/display'\nimport type { Row } from '../../../types/editable'\n\nconst notSharp = (c: string) => c !== '#'\n\nexport const mergeRows = (state: Row[]) => {\n  if (state.length < 2) {\n    return state\n  }\n\n  const [newCellsAcc, lastRow] = reduce(\n    ([rowsAcc, rowA]: [Row[], Row], rowB: Row) => {\n      const numberOfCells = path(['cells', 'length'])\n\n      if (numberOfCells(rowA) !== 1 || numberOfCells(rowB) !== 1) {\n        return [\n          [...rowsAcc, { ...rowA, id: takeWhile(notSharp, rowA.id).join('') }],\n          rowB\n        ]\n      }\n\n      const cellA = rowA.cells[0]\n      const cellB = rowB.cells[0]\n\n      const pluginName = path(['content', 'plugin', 'name'])\n      const pluginVersion = path(['content', 'plugin', 'version'])\n      const pluginMerge = path(['content', 'plugin', 'merge'])\n\n      if (\n        !pluginName(cellA) || !pluginName(cellB)\n        || !pluginVersion(cellA) || !pluginVersion(cellB)\n        || pluginName(cellA) !== pluginName(cellB)\n        || pluginVersion(cellA) !== pluginVersion(cellB)\n        || !pluginMerge(cellA)\n      ) {\n        return [\n          [...rowsAcc, { ...rowA, id: takeWhile(notSharp, rowA.id).join('') }],\n          rowB\n        ]\n      }\n\n      return [\n        rowsAcc,\n        {\n          ...rowA,\n          id: takeWhile(notSharp, rowA.id).join(''),\n          cells: [{\n            ...cellA,\n            id: takeWhile(notSharp, cellA.id).join(''),\n            content: {\n              ...cellA.content,\n              state: pluginMerge(cellA)(\n                [cellA.content.state, cellB.content.state]\n              )\n            }\n          }]\n        }\n      ]\n    },\n    [[], head(state)],\n    tail(state)\n  )\n\n  return [...newCellsAcc, lastRow]\n}\n\nexport const splitRows = (state: Row[]) => (\n  flatten(map(\n    (row: Row) => {\n      if (!row.cells) {\n        return [row]\n      }\n\n      if (row.cells.length !== 1) {\n        return [row]\n      }\n\n      const state = path(['cells', 0, 'content', 'state'], row)\n      const split = path(['cells', 0, 'content', 'plugin', 'split'], row)\n\n      if (!split) {\n        return [row]\n      }\n\n      return split(state).map((state: Object, i: number) => ({\n        ...row,\n        id: `${row.id}#${i}`,\n        cells: [{\n          ...row.cells[0],\n          id: `${row.cells[0].id}#${i}`,\n          content: {\n            ...row.cells[0].content,\n            state\n          }\n        }]\n      }))\n    },\n    state\n  ))\n)\n\nexport const mergeDecorator = (action: Object) => (state: Row[]) => {\n  if (action.type !== SET_DISPLAY_MODE) {\n    return state\n  }\n\n  switch (action.mode) {\n    case 'edit':\n      return mergeRows(state)\n    case 'insert':\n    case 'layout': {\n      return splitRows(state)\n    }\n    default:\n      return state\n  }\n}\n"]}