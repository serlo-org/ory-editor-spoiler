'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LayoutPlugin = exports.ContentPlugin = exports.Plugin = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/* eslint-disable no-empty-function, no-unused-vars */


/**
 * @class the abstract class for content and layout plugins. It will be instantiated once and used for every cell that is equipped with it.
 */
var Plugin = exports.Plugin = function Plugin(config) {
  _classCallCheck(this, Plugin);

  this.serialize = function (raw) {
    return raw;
  };

  this.unserialize = function (state) {
    return state;
  };

  var name = config.name,
      version = config.version,
      Component = config.Component,
      IconComponent = config.IconComponent,
      text = config.text,
      serialize = config.serialize,
      unserialize = config.unserialize;


  if (!name || !version || !Component) {
    throw new Error('A plugin\'s version, name and Component must be defined, got ' + JSON.stringify(config));
  }

  this.name = name;
  this.version = version;
  this.Component = Component;

  this.IconComponent = IconComponent;
  this.text = text;

  this.serialize = serialize ? serialize.bind(this) : this.serialize;
  this.unserialize = unserialize ? unserialize.bind(this) : this.unserialize;
}

/**
 * @member a unique identifier of the plugin
 */


/**
 * @member the semantic version (www.semver.org) of this plugin.
 */


/**
 * @member the icon that will be shown in the toolbar.
 */

// IconComponent: Element<*> | Component<*, *, *>

/**
 * @member the plugin's react component.
 */

// Component: Element<*> | Component<*, *, *> | (props: any) => Element<*>

/**
 * @member the text that will be shown alongside the icon in the toolbar.
 */


/**
 * Serialize a the plugin state
 *
 * @param raw the raw state.
 * @returns the serialized state.
 */


/**
 * Unserialize the plugin state.
 *
 * @param state the plugin state.
 * @returns the unserialized state.
 */
;

/**
 * @class this is the base class for content plugins.
 */


var ContentPlugin = exports.ContentPlugin = function (_Plugin) {
  _inherits(ContentPlugin, _Plugin);

  function ContentPlugin(config) {
    _classCallCheck(this, ContentPlugin);

    var _this = _possibleConstructorReturn(this, (ContentPlugin.__proto__ || Object.getPrototypeOf(ContentPlugin)).call(this, config));

    _this.createInitialState = function () {
      return {};
    };

    _this.handleRemoveHotKey = function (e, props) {
      return Promise.reject();
    };

    _this.handleFocusNextHotKey = function (e, props) {
      return Promise.resolve();
    };

    _this.handleFocusPreviousHotKey = function (e, props) {
      return Promise.resolve();
    };

    _this.handleFocus = function (props) {};

    _this.handleBlur = function (props) {};

    _this.reducer = function (state, action) {
      return state;
    };

    var handleRemoveHotKey = config.handleRemoveHotKey,
        handleFocusNextHotKey = config.handleFocusNextHotKey,
        handleFocusPreviousHotKey = config.handleFocusPreviousHotKey,
        handleFocus = config.handleFocus,
        handleBlur = config.handleBlur,
        createInitialState = config.createInitialState,
        _config$allowInlineNe = config.allowInlineNeighbours,
        allowInlineNeighbours = _config$allowInlineNe === undefined ? false : _config$allowInlineNe,
        _config$isInlineable = config.isInlineable,
        isInlineable = _config$isInlineable === undefined ? false : _config$isInlineable,
        reducer = config.reducer;


    _this.isInlineable = isInlineable;
    _this.allowInlineNeighbours = allowInlineNeighbours;
    _this.handleRemoveHotKey = handleRemoveHotKey ? handleRemoveHotKey.bind(_this) : _this.handleRemoveHotKey;
    _this.handleFocusNextHotKey = handleFocusNextHotKey ? handleFocusNextHotKey.bind(_this) : _this.handleFocusNextHotKey;
    _this.handleFocusPreviousHotKey = handleFocusPreviousHotKey ? handleFocusPreviousHotKey.bind(_this) : _this.handleFocusPreviousHotKey;
    _this.handleFocus = handleFocus ? handleFocus.bind(_this) : _this.handleFocus;
    _this.handleBlur = handleBlur ? handleBlur.bind(_this) : _this.handleBlur;
    _this.reducer = reducer ? reducer.bind(_this) : _this.reducer;
    _this.createInitialState = createInitialState ? createInitialState.bind(_this) : _this.createInitialState;
    return _this;
  }

  /**
   * @member if isInlineable is true, the plugin is allowed to be placed with floating to left or right.
   */


  /**
   * @member if true allows that isInlineable elements may be placed "in" this plugin.
   */


  /**
   * Create the plugin's initial state.
   *
   * @returns the initial state.
   */


  /**
   * Will be called when the user presses the delete key. When returning a resolving promise,
   * the cell will be removed. If the promise is rejected, nothing happens.
   *
   * @param e
   * @param props
   * @returns a promise
   */


  /**
   * Will be called when the user presses the right or down key. When returning a resolving promise,
   * the next cell will be focused. If the promise is rejected, focus stays the same.
   *
   * @param e
   * @param props
   * @returns a promise
   */


  /**
   * Will be called when the user presses the left or up key. When returning a resolving promise,
   * the next cell will be focused. If the promise is rejected, focus stays the same.
   *
   * @param e
   * @param props
   * @returns a promise
   */


  /**
   * This function will be called when one of the plugin's cell is blurred.
   *
   * @param props
   */


  /**
   * This function will be called when one of the plugin's cell is focused.
   *
   * @param props
   */


  /**
   * Specify a custom reducer for the plugin's cell.
   *
   * @param state
   * @param action
   */


  return ContentPlugin;
}(Plugin);

/**
 * @class this is the base class for layout plugins.
 */


var LayoutPlugin = exports.LayoutPlugin = function (_Plugin2) {
  _inherits(LayoutPlugin, _Plugin2);

  function LayoutPlugin(config) {
    _classCallCheck(this, LayoutPlugin);

    var _this2 = _possibleConstructorReturn(this, (LayoutPlugin.__proto__ || Object.getPrototypeOf(LayoutPlugin)).call(this, config));

    _this2.createInitialState = function () {
      return {};
    };

    _this2.createInitialChildren = function () {
      return {};
    };

    var createInitialState = config.createInitialState,
        createInitialChildren = config.createInitialChildren;


    _this2.createInitialState = createInitialState ? createInitialState.bind(_this2) : _this2.createInitialState;
    _this2.createInitialChildren = createInitialChildren ? createInitialChildren.bind(_this2) : _this2.createInitialChildren;
    return _this2;
  }

  /**
   * Create the plugin's initial state.
   *
   * @returns the initial state.
   */


  /**
   * Create the plugin's initial children (rows/cells).
   *
   * @returns the initial state.
   */


  return LayoutPlugin;
}(Plugin);
//# sourceMappingURL=classes.js.map