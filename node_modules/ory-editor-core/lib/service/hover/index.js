'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultCallbacks = exports.computeVertical = exports.computeHorizontal = exports.computeLevel = exports.relativeMousePosition = exports.computeHover = exports.getMouseHoverCell = exports.getRoomScale = exports.defaultMatrices = exports.classes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _defaultCallbacks;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _deepEqual = require('deep-equal');

var _deepEqual2 = _interopRequireDefault(_deepEqual);

var _logger = require('../logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * NO (None): No drop zone.
 *
 * Corners are counted clockwise, beginning top left
 * C1 (Corner top left): Position decided by top left corner function
 * C2 (Corner top right): Position decided by top right corner function
 * C3 (Corner bottom right): Position decided by bottom right corner function
 * C4 (Corner bottom left): Position decided by bottom left corner function
 *
 * Above:
 * AH (Above here): above, same level
 * AA (Above of self or some ancestor): Above, compute active level using classification functions, e.g. log, sin, mx + t
 *
 * Below:
 * BH (Below here)
 * BA (Below of self or some ancestor)
 *
 * Left of:
 * LH (Left of here)
 * LA (Left of self or some ancestor)
 *
 * Right of:
 * RH (Right of here)
 * RA (Right of self or some ancestor)
 *
 * Inside / inline
 * IL (Inline left)
 * IR (Inline right)
 */
var classes = exports.classes = {
  NO: 0,

  C1: 10,
  C2: 11,
  C3: 12,
  C4: 13,

  AH: 200,
  AA: 201,

  BH: 210,
  BA: 211,

  LH: 220,
  LA: 221,

  RH: 230,
  RA: 231,

  IL: 300,
  IR: 301
};

var c = classes;

/**
 * A list of matrices that are used to define the callback function.
 *
 * @type {{6x6: *[], 10x10: *[], 10x10-no-inline: *[]}}
 */
var defaultMatrices = exports.defaultMatrices = {
  '6x6': [[c.C1, c.AA, c.AA, c.AA, c.AA, c.C2], [c.LA, c.IL, c.AH, c.AH, c.IR, c.RA], [c.LA, c.LH, c.NO, c.NO, c.RH, c.RA], [c.LA, c.LH, c.NO, c.NO, c.RH, c.RA], [c.LA, c.C4, c.BH, c.BH, c.C3, c.RA], [c.C4, c.BA, c.BA, c.BA, c.BA, c.C3]],
  '10x10': [[c.C1, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.C2], [c.LA, c.IL, c.IL, c.IL, c.AH, c.AH, c.IR, c.IR, c.IR, c.RA], [c.LA, c.IL, c.IL, c.IL, c.AH, c.AH, c.IR, c.IR, c.IR, c.RA], [c.LA, c.IL, c.IL, c.IL, c.AH, c.AH, c.IR, c.IR, c.IR, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C1, c.C2, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C4, c.C3, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.C4, c.BH, c.BH, c.C3, c.IR, c.RH, c.RA], [c.LA, c.LH, c.C4, c.BH, c.BH, c.BH, c.BH, c.C3, c.RH, c.RA], [c.LA, c.C4, c.BH, c.BH, c.BH, c.BH, c.BH, c.BH, c.C3, c.RA], [c.C4, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.C3]],
  '10x10-no-inline': [[c.C1, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.AA, c.C2], [c.LA, c.C1, c.AH, c.AH, c.AH, c.AH, c.AH, c.AH, c.C2, c.RA], [c.LA, c.LH, c.C1, c.AH, c.AH, c.AH, c.AH, c.C2, c.RH, c.RA], [c.LA, c.LH, c.LH, c.C1, c.AH, c.AH, c.C2, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C1, c.C2, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.LH, c.C4, c.C3, c.RH, c.RH, c.RH, c.RA], [c.LA, c.LH, c.LH, c.C4, c.BH, c.BH, c.C3, c.RH, c.RH, c.RA], [c.LA, c.LH, c.C4, c.BH, c.BH, c.BH, c.BH, c.C3, c.RH, c.RA], [c.LA, c.C4, c.BH, c.BH, c.BH, c.BH, c.BH, c.BH, c.C3, c.RA], [c.C4, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.BA, c.C3]]
};

/**
 * Computes the average width and height for cells in a room.
 *
 * @param room
 * @param matrix
 * @returns {{x: number, y: number}}
 */
var getRoomScale = exports.getRoomScale = function getRoomScale(_ref) {
  var room = _ref.room,
      matrix = _ref.matrix;

  var rows = matrix.length;
  var cells = matrix[0].length;

  var scalingX = room.width / cells;
  var scalingY = room.height / rows;

  return {
    x: scalingX,
    y: scalingY
  };
};

/**
 * Returns the index of the hover cell.
 *
 * @param mouse
 * @param scale
 */
var getMouseHoverCell = exports.getMouseHoverCell = function getMouseHoverCell(_ref2) {
  var mouse = _ref2.mouse,
      scale = _ref2.scale;
  return {
    cell: Math.floor(mouse.x / scale.x),
    row: Math.floor(mouse.y / scale.y)
  };
};

/**
 * Used for caching.
 */
var last = { '10x10': null, '10x10-no-inline': null };

var computeHover = exports.computeHover = function computeHover(item, hover, actions, _ref3, m) {
  var room = _ref3.room,
      mouse = _ref3.mouse,
      matrix = _ref3.matrix,
      callbacks = _ref3.callbacks;

  var scale = getRoomScale({ room: room, matrix: matrix });
  var hoverCell = getMouseHoverCell({ mouse: mouse, scale: scale });
  var rows = matrix.length;
  var cells = matrix[0].length;

  if (hoverCell.row >= rows) {
    hoverCell.row = rows - 1;
  } else if (hoverCell.row < 0) {
    hoverCell.row = 0;
  }

  if (hoverCell.cell >= cells) {
    hoverCell.cell = cells - 1;
  } else if (hoverCell.cell < 0) {
    hoverCell.cell = 0;
  }

  var cell = matrix[hoverCell.row][hoverCell.cell];
  if (!callbacks[cell]) {
    _logger2.default.error('Matrix callback not found.', { room: room, mouse: mouse, matrix: matrix, scale: scale, hoverCell: hoverCell, rows: rows, cells: cells });
    return;
  }

  var all = {
    item: item.id, hover: hover.id, actions: actions, ctx: {
      room: room,
      mouse: mouse,
      position: hoverCell,
      size: { rows: rows, cells: cells },
      scale: scale
    }
  };
  if ((0, _deepEqual2.default)(all, last[m])) {
    return;
  }
  last[m] = all;

  return callbacks[cell](item, hover, actions, {
    room: room,
    mouse: mouse,
    position: hoverCell,
    size: { rows: rows, cells: cells },
    scale: scale
  });
};

/**
 * Return the mouse position relative to the cell.
 */
var relativeMousePosition = exports.relativeMousePosition = function relativeMousePosition(_ref4) {
  var mouse = _ref4.mouse,
      position = _ref4.position,
      scale = _ref4.scale;
  return {
    x: Math.round(mouse.x - position.cell * scale.x),
    y: Math.round(mouse.y - position.row * scale.y)
  };
};

/**
 * Computes the drop level based on the mouse position and the cell width.
*/
var computeLevel = exports.computeLevel = function computeLevel(_ref5) {
  var size = _ref5.size,
      levels = _ref5.levels,
      position = _ref5.position;

  if (size <= (levels + 1) * 2) {
    return Math.round(position / (size / levels));
  }

  var spare = size - (levels + 1) * 2;
  var steps = [0];
  var current = spare;
  for (var i = 0; i <= levels; i++) {
    steps.push(steps[i] + current / 2);
    current /= 2;
    if (position >= steps[i] + i * 2 && position < steps[i + 1] + (i + 1) * 2) {
      return i;
    }
  }

  return levels;
};

/**
 * Computes the horizontal drop level based on the mouse position.
 *
 * @param mouse
 * @param position
 * @param hover
 * @param scale
 * @param level
 * @param inv returns the inverse drop level. Usually true for left and above drop level computation.
 * @returns number
 */
var computeHorizontal = exports.computeHorizontal = function computeHorizontal(_ref6) {
  var mouse = _ref6.mouse,
      position = _ref6.position,
      hover = _ref6.hover,
      scale = _ref6.scale,
      level = _ref6.level;
  var inv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var _hover$node$cells = hover.node.cells,
      cells = _hover$node$cells === undefined ? [] : _hover$node$cells;

  var x = relativeMousePosition({ mouse: mouse, position: position, scale: scale }).x;
  var at = computeLevel({ size: scale.x, position: x, levels: level });

  if (cells.length) {
    // Is row, always opt for lowest level
    return level;
  }

  // If the hovered element is an inline element, level 0 would be directly besides it which doesn't work.
  // Set it to 1 instead.
  if (hover.node.inline && at === 0) {
    at = 1;
  }

  return inv ? level - at : at;
};

/**
 * Computes the vertical drop level based on the mouse position.
 *
 * @returns number
 */
var computeVertical = exports.computeVertical = function computeVertical(_ref7) {
  var level = _ref7.level,
      mouse = _ref7.mouse,
      hover = _ref7.hover,
      position = _ref7.position,
      scale = _ref7.scale;
  var inv = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var _hover$node$cells2 = hover.node.cells,
      cells = _hover$node$cells2 === undefined ? [] : _hover$node$cells2;

  var y = relativeMousePosition({ mouse: mouse, position: position, scale: scale }).y;
  var at = computeLevel({ size: scale.y, position: y, levels: level });

  if (cells.length) {
    // Is row, always opt for lowest level
    return level;
  }

  // If the hovered element is an inline element, level 0 would be directly besides it which doesn't work.
  // Set it to 1 instead.
  if (hover.node.inline && at === 0) {
    at = 1;
  }

  return inv ? level - at : at;
};

var getDropLevel = function getDropLevel(hover) {
  return hover.node.inline ? 1 : 0;
};

/**
 * A list of callbacks.
 */
var defaultCallbacks = exports.defaultCallbacks = (_defaultCallbacks = {}, _defineProperty(_defaultCallbacks, c.NO, function (item, hover, _ref8) {
  var clear = _ref8.clear;
  return clear(item.id);
}), _defineProperty(_defaultCallbacks, c.C1, function (item, hover, _ref9, ctx) {
  var leftOf = _ref9.leftOf,
      above = _ref9.above;

  var mouse = relativeMousePosition(ctx);
  var level = getDropLevel(hover);

  if (mouse.x < mouse.y) {
    return leftOf(item.rawNode(), hover.rawNode(), level);
  }

  above(item.rawNode(), hover.rawNode(), level);
}), _defineProperty(_defaultCallbacks, c.C2, function (item, hover, _ref10, ctx) {
  var rightOf = _ref10.rightOf,
      above = _ref10.above;

  var mouse = relativeMousePosition(ctx);
  var level = getDropLevel(hover);

  if (mouse.x > mouse.y) {
    return rightOf(item.rawNode(), hover.rawNode(), level);
  }

  above(item.rawNode(), hover.rawNode(), level);
}), _defineProperty(_defaultCallbacks, c.C3, function (item, hover, _ref11, ctx) {
  var rightOf = _ref11.rightOf,
      below = _ref11.below;

  var mouse = relativeMousePosition(ctx);
  var level = getDropLevel(hover);

  if (mouse.x > mouse.y) {
    return rightOf(item.rawNode(), hover.rawNode(), level);
  }
  below(item.rawNode(), hover.rawNode(), level);
}), _defineProperty(_defaultCallbacks, c.C4, function (item, hover, _ref12, ctx) {
  var leftOf = _ref12.leftOf,
      below = _ref12.below;

  var mouse = relativeMousePosition(ctx);
  var level = getDropLevel(hover);

  if (mouse.x < mouse.y) {
    return leftOf(item.rawNode(), hover.rawNode(), level);
  }
  below(item.rawNode(), hover.rawNode(), level);
}), _defineProperty(_defaultCallbacks, c.AH, function (item, hover, _ref13) {
  var above = _ref13.above;

  var level = getDropLevel(hover);
  above(item.rawNode(), _extends({}, hover.rawNode()), level);
}), _defineProperty(_defaultCallbacks, c.BH, function (item, hover, _ref14) {
  var below = _ref14.below;

  var level = getDropLevel(hover);
  below(item.rawNode(), _extends({}, hover.rawNode()), level);
}), _defineProperty(_defaultCallbacks, c.LH, function (item, hover, _ref15) {
  var leftOf = _ref15.leftOf;

  var level = getDropLevel(hover);
  leftOf(item.rawNode(), _extends({}, hover.rawNode()), level);
}), _defineProperty(_defaultCallbacks, c.RH, function (item, hover, _ref16) {
  var rightOf = _ref16.rightOf;

  var level = getDropLevel(hover);
  rightOf(item.rawNode(), _extends({}, hover.rawNode()), level);
}), _defineProperty(_defaultCallbacks, c.AA, function (item, hover, _ref17, ctx) {
  var above = _ref17.above;
  return above(item.rawNode(), hover.rawNode(), computeVertical(_extends({}, ctx, {
    hover: hover,
    level: hover.node.levels.above
  }), true));
}), _defineProperty(_defaultCallbacks, c.BA, function (item, hover, _ref18, ctx) {
  var below = _ref18.below;
  return below(item.rawNode(), hover.rawNode(), computeVertical(_extends({}, ctx, {
    hover: hover,
    level: hover.node.levels.below
  })));
}), _defineProperty(_defaultCallbacks, c.LA, function (item, hover, _ref19, ctx) {
  var leftOf = _ref19.leftOf;
  return leftOf(item.rawNode(), hover.rawNode(), computeHorizontal(_extends({}, ctx, {
    hover: hover,
    level: hover.node.levels.left
  }), true));
}), _defineProperty(_defaultCallbacks, c.RA, function (item, hover, _ref20, ctx) {
  var rightOf = _ref20.rightOf;
  return rightOf(item.rawNode(), hover.rawNode(), computeHorizontal(_extends({}, ctx, {
    hover: hover,
    level: hover.node.levels.right
  })));
}), _defineProperty(_defaultCallbacks, c.IL, function (item, hover, _ref21) {
  var inlineLeft = _ref21.inlineLeft,
      leftOf = _ref21.leftOf;
  var _hover$node = hover.node,
      inline = _hover$node.inline,
      hasInlineNeighbour = _hover$node.hasInlineNeighbour;
  var _item$node$content = item.node.content;
  _item$node$content = _item$node$content === undefined ? {} : _item$node$content;
  var _item$node$content$pl = _item$node$content.plugin;
  _item$node$content$pl = _item$node$content$pl === undefined ? {} : _item$node$content$pl;
  var _item$node$content$pl2 = _item$node$content$pl.isInlineable,
      isInlineable = _item$node$content$pl2 === undefined ? false : _item$node$content$pl2;

  if (inline || !isInlineable) {
    return leftOf(item.rawNode(), hover.rawNode(), 2);
  }
  if (hasInlineNeighbour && hasInlineNeighbour !== item.id) {
    return leftOf(item.rawNode(), hover.rawNode(), 2);
  }
  if (hasInlineNeighbour && hasInlineNeighbour === item.id && item.node.inline === 'left') {
    return leftOf(item.rawNode(), hover.rawNode(), 2);
  }

  inlineLeft(item.rawNode(), hover.rawNode());
}), _defineProperty(_defaultCallbacks, c.IR, function (item, hover, _ref22) {
  var inlineRight = _ref22.inlineRight,
      rightOf = _ref22.rightOf;
  var _hover$node2 = hover.node,
      inline = _hover$node2.inline,
      hasInlineNeighbour = _hover$node2.hasInlineNeighbour;
  var _item$node$content2 = item.node.content;
  _item$node$content2 = _item$node$content2 === undefined ? {} : _item$node$content2;
  var _item$node$content2$p = _item$node$content2.plugin;
  _item$node$content2$p = _item$node$content2$p === undefined ? {} : _item$node$content2$p;
  var _item$node$content2$p2 = _item$node$content2$p.isInlineable,
      isInlineable = _item$node$content2$p2 === undefined ? false : _item$node$content2$p2;

  if (inline || !isInlineable) {
    return rightOf(item.rawNode(), hover.rawNode(), 2);
  }
  if (hasInlineNeighbour && hasInlineNeighbour !== item.id) {
    return rightOf(item.rawNode(), hover.rawNode(), 2);
  }
  if (hasInlineNeighbour && hasInlineNeighbour === item.id && item.node.inline === 'right') {
    return rightOf(item.rawNode(), hover.rawNode(), 2);
  }

  inlineRight(item.rawNode(), hover.rawNode());
}), _defaultCallbacks);

/**
 * The HoverService uses callbacks and matrices to compute hover logic.
 *
 * @class HoverService
 */

var HoverService = function () {
  function HoverService() {
    var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        matrices = _ref23.matrices,
        callbacks = _ref23.callbacks;

    _classCallCheck(this, HoverService);

    this.callbacks = defaultCallbacks;
    this.matrices = defaultMatrices;

    this.matrices = matrices || this.matrices;
    this.callbacks = callbacks || this.callbacks;
  }

  _createClass(HoverService, [{
    key: 'hover',
    value: function hover(item, _hover, actions, _ref24) {
      var room = _ref24.room,
          mouse = _ref24.mouse,
          _ref24$matrix = _ref24.matrix,
          use = _ref24$matrix === undefined ? '10x10' : _ref24$matrix;

      return computeHover(item, _hover, actions, {
        room: room,
        mouse: mouse,
        matrix: this.matrices[use],
        callbacks: this.callbacks
      }, use);
    }
  }]);

  return HoverService;
}();

exports.default = HoverService;
//# sourceMappingURL=index.js.map