'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeAndDispatchHover = exports.computeAndDispatchInsert = exports.computeCurrentDropPosition = undefined;

var _reactDom = require('react-dom');

var _hover = require('../hover');

var _hover2 = _interopRequireDefault(_hover);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var hoverService = new _hover2.default();

var computeCurrentDropPosition = exports.computeCurrentDropPosition = function computeCurrentDropPosition(actions, hover, monitor, component, matrixName) {
  var drag = monitor.getItem();
  var mousePosition = monitor.getClientOffset();
  /* eslint-disable react/no-find-dom-node */
  var componentPosition = (0, _reactDom.findDOMNode)(component).getBoundingClientRect();
  var room = {
    height: componentPosition.bottom - componentPosition.top,
    width: componentPosition.right - componentPosition.left
  };

  var mouse = {
    y: mousePosition.y - componentPosition.top,
    x: mousePosition.x - componentPosition.left
  };

  hoverService.hover(drag, hover, actions, { room: room, mouse: mouse, matrix: matrixName });
};

var computeAndDispatchInsert = function computeAndDispatchInsert(_ref, monitor, component) {
  var matrixName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '10x10';

  var above = _ref.insertCellAbove,
      below = _ref.insertCellBelow,
      leftOf = _ref.insertCellLeftOf,
      rightOf = _ref.insertCellRightOf,
      inlineLeft = _ref.insertCellLeftInline,
      inlineRight = _ref.insertCellRightInline,
      clear = _ref.clearHover,
      hover = _objectWithoutProperties(_ref, ['insertCellAbove', 'insertCellBelow', 'insertCellLeftOf', 'insertCellRightOf', 'insertCellLeftInline', 'insertCellRightInline', 'clearHover']);

  return computeCurrentDropPosition({
    clear: clear,
    above: above,
    below: below,
    leftOf: leftOf,
    rightOf: rightOf,
    inlineLeft: inlineLeft,
    inlineRight: inlineRight
  }, hover, monitor, component, matrixName);
};

exports.computeAndDispatchInsert = computeAndDispatchInsert;
var computeAndDispatchHover = function computeAndDispatchHover(_ref2, monitor, component) {
  var matrixName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '10x10';

  var above = _ref2.cellHoverAbove,
      below = _ref2.cellHoverBelow,
      leftOf = _ref2.cellHoverLeftOf,
      rightOf = _ref2.cellHoverRightOf,
      inlineLeft = _ref2.cellHoverInlineLeft,
      inlineRight = _ref2.cellHoverInlineRight,
      clear = _ref2.clearHover,
      hover = _objectWithoutProperties(_ref2, ['cellHoverAbove', 'cellHoverBelow', 'cellHoverLeftOf', 'cellHoverRightOf', 'cellHoverInlineLeft', 'cellHoverInlineRight', 'clearHover']);

  return computeCurrentDropPosition({
    clear: clear,
    above: above,
    below: below,
    leftOf: leftOf,
    rightOf: rightOf,
    inlineLeft: inlineLeft,
    inlineRight: inlineRight
  }, hover, monitor, component, matrixName);
};
exports.computeAndDispatchHover = computeAndDispatchHover;
//# sourceMappingURL=input.js.map