{"version":3,"sources":["../../../../src/components/Cell/Content/index.js"],"names":["Content","shouldComponentUpdate","onRef","ref","nextProps","was","props","node","focused","is","focusSource","isEditMode","editable","id","content","plugin","handleFocus","handleBlur","name","version","state","updateCellContent","pass","readOnly","onChange","isPreviewMode","Component","focusCell","blurCell","focusProps","onMouseDown","source","outline","mapStateToProps","isLayoutMode","mapDispatchToProps","dispatch"],"mappings":"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","file":"index.js","sourcesContent":["// @flow\nimport React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { bindActionCreators } from 'redux'\nimport { createStructuredSelector } from 'reselect'\n\nimport { updateCellContent } from '../../../actions/cell'\nimport { shouldPureComponentUpdate } from '../../../helper/shouldComponentUpdate'\nimport { isEditMode, isLayoutMode, isPreviewMode } from '../../../selector/display'\n\nimport type { ComponentizedCell } from '../../../types/editable'\n\n// TODO clean me up #157\nclass Content extends Component {\n  componentWillReceiveProps(nextProps: ComponentizedCell) {\n    const { node: { focused: was } } = this.props\n    const { node: { focused: is, focusSource } } = nextProps\n    const { isEditMode, editable, id, node: { content: { plugin: { handleFocus, handleBlur, name, version }, state = {} } = {}, focused }, updateCellContent } = nextProps\n\n    // FIXME this is really shitty because it will break when the state changes before the blur comes through, see #157\n    const pass = {\n      editable,\n      id,\n      state,\n      focused: isEditMode && focused,\n      readOnly: !isEditMode,\n      onChange: updateCellContent,\n      name, version\n    }\n\n    // Basically we check if the focus state changed and if yes, we execute the callback handler from the plugin, that\n    // can set some side effects.\n    if (!was && is) {\n      // We need this because otherwise we lose hotkey focus on elements like spoilers.\n      // This could probably be solved in an easier way by listening to window.document?\n      handleFocus(pass, focusSource, this.ref)\n    } else if (was && !is) {\n      handleBlur(pass)\n    }\n  }\n\n  shouldComponentUpdate = shouldPureComponentUpdate\n  props: ComponentizedCell\n  ref: HTMLElement\n\n  onRef = (ref: any) => {\n    this.ref = ref\n  }\n\n  render() {\n    const { isPreviewMode, isEditMode, editable, id, node: { content: { plugin: { Component, name, version }, state = {} } = {}, focused }, updateCellContent } = this.props\n    const { focusCell, blurCell } = this.props\n\n    let focusProps\n    if (!isPreviewMode) {\n      focusProps = {\n        onMouseDown: () => {\n          if (!focused) {\n            focusCell({ source: 'onMouseDown' })\n          }\n          return true\n        }\n      }\n    }\n\n    return (\n      <div {...focusProps}\n        tabIndex=\"-1\"\n        style={{ outline: 'none' }}\n        ref={this.onRef}\n        className=\"ory-cell-inner ory-cell-leaf\"\n      >\n        <Component\n          editable={editable}\n          id={id}\n          state={state}\n          focused={isEditMode && focused}\n          name={name}\n          version={version}\n          readOnly={!isEditMode}\n          onChange={updateCellContent}\n          focus={focusCell}\n          blur={blurCell}\n        />\n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = createStructuredSelector({ isEditMode, isLayoutMode, isPreviewMode })\n\nconst mapDispatchToProps = (dispatch: Function, { id }: ComponentizedCell) => bindActionCreators({\n  updateCellContent: updateCellContent(id)\n}, dispatch)\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Content)\n"]}