'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connect = exports.target = undefined;

var _lodash = require('lodash.throttle');

var _lodash2 = _interopRequireDefault(_lodash);

var _pathOr = require('ramda/src/pathOr');

var _pathOr2 = _interopRequireDefault(_pathOr);

var _input = require('../../../../service/hover/input');

var _throttle = require('../../../../helper/throttle');

var _logger = require('../../../../service/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var last = { hover: '', drag: '' };


var clear = function clear(hover, drag) {
  if (hover.id === last.hover && drag === last.drag) {
    return;
  }
  last = { hover: hover.id, drag: drag };
  hover.clearHover();
};

var target = exports.target = {
  hover: (0, _lodash2.default)(function (hover, monitor, component) {
    var drag = monitor.getItem();

    if (!drag) {
      // item undefined, happens when throttle triggers after drop
      return;
    } else if (drag.id === hover.id) {
      // If hovering over itself, do nothing
      clear(hover, drag.id);
      return;
    } else if (!monitor.isOver({ shallow: true })) {
      // If hovering over ancestor cell, do nothing (we are going to propagate later in the tree anyways)
      return;
    } else if (hover.ancestors.indexOf(drag.id) > -1) {
      // If hovering over a child of itself
      clear(hover, drag.id);
      return;
    } else if (!hover.id) {
      // If hovering over something that isn't a cell or hasn't an id, do nothing. Should be an edge case
      _logger2.default.warn('Canceled cell drop, no id given.', hover, drag);
      return;
    }

    last = { hover: hover.id, drag: drag.id };
    var allowInlineNeighbours = (0, _pathOr2.default)(false, ['node', 'content', 'plugin', 'allowInlineNeighbours'], hover);
    (0, _input.computeAndDispatchHover)(hover, monitor, component, '10x10' + (allowInlineNeighbours ? '' : '-no-inline'));
  }, _throttle.delay, { leading: false }),

  canDrop: function canDrop(_ref, monitor) {
    var id = _ref.id,
        ancestors = _ref.ancestors;

    var item = monitor.getItem();
    return item.id !== id && ancestors.indexOf(item.id) === -1;
  },

  drop: function drop(hover, monitor, component) {
    var drag = monitor.getItem();

    if (monitor.didDrop() || !monitor.isOver({ shallow: true })) {
      // If the item drop occurred deeper down the tree, don't do anything
      return;
    } else if (drag.id === hover.id) {
      // If the item being dropped on itself do nothing
      hover.cancelCellDrag(drag.id);
      return;
    } else if (hover.ancestors.indexOf(drag.id) > -1) {
      // If hovering over a child of itself, don't propagate further
      hover.cancelCellDrag(drag.id);
      return;
    }

    last = { hover: hover.id, drag: drag.id };
    var allowInlineNeighbours = (0, _pathOr2.default)(false, ['node', 'content', 'plugin', 'allowInlineNeighbours'], hover);
    (0, _input.computeAndDispatchInsert)(hover, monitor, component, '10x10' + (allowInlineNeighbours ? '' : '-no-inline'));
  }
};

var connect = exports.connect = function connect(_connect, monitor) {
  return {
    connectDropTarget: _connect.dropTarget(),
    isOver: monitor.isOver(),
    isOverCurrent: monitor.isOver({ shallow: true })
  };
};
//# sourceMappingURL=dnd.js.map