{"version":3,"sources":["../../../src/components/HotKey/Handler.js"],"names":["hotKeyHandler","n","key","Promise","resolve","nextLeaf","order","current","last","find","c","isLeaf","id","previousLeaf","reverse","falser","err","console","log","handlers","props","undo","redo","focus","removeCell","focusCell","blurAllCells","isEditMode","node","editable","remove","e","then","catch","focusNext","found","cellOrder","focusPrev","Decorator","outline","children","mapStateToProps","state","mapDispatchToProps"],"mappings":"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","file":"Handler.js","sourcesContent":["// @flow\n/* eslint-disable no-empty-function */\nimport React from 'react'\nimport { HotKeys } from 'react-hotkeys'\nimport { connect } from 'react-redux'\nimport pathOr from 'ramda/src/pathOr'\nimport { createStructuredSelector } from 'reselect'\n\nimport { undo, redo } from '../../actions/undo'\nimport { removeCell, focusCell, blurAllCells } from '../../actions/cell'\nimport { isEditMode } from '../../selector/display'\nimport { focus } from '../../selector/focus'\nimport { node, editable } from '../../selector/editable'\n\nimport type { Editable } from '../../types/editable'\n\nconst hotKeyHandler = (n: Object, key: string) => pathOr(pathOr(() => Promise.resolve(), ['content', 'plugin', key], n), ['layout', 'plugin', key], n)\n\nconst nextLeaf = (order: [] = [], current: string) => {\n  let last\n\n  return order.find((c: {id: string, isLeaf: boolean}) => {\n    if (last === current) {\n      return c.isLeaf\n    }\n    last = c.id\n    return false\n  })\n}\n\nconst previousLeaf = (order: [], current: string) => nextLeaf([...order].reverse(), current)\n\ntype Props = {\n  children: any,\n  id: string,\n  undo(id: string): void,\n  redo(id: string): void,\n  removeCell(id: string): void,\n  focus: string,\n  focusCell(id: string): void,\n  blurAllCells(): void,\n  updateCellContent(): any,\n  updateCellLayout(): any,\n  isEditMode: boolean,\n  node(cell: string, editable: string): Object,\n  editable: Editable\n}\n\nconst falser = (err: Error) => {\n  if (err) {\n    console.log(err)\n  }\n}\n\n// TODO cleanup and tests #143\nconst handlers = (props: Props) => {\n  const { id, undo, redo, focus, removeCell, focusCell, blurAllCells, isEditMode, node, editable } = props\n  return ({\n    undo: () => undo(id),\n    redo: () => redo(id),\n\n    // remove cells\n    remove: (e: Event) => {\n      if (!isEditMode) {\n        return\n      }\n\n      const n = node(focus, id)\n      hotKeyHandler(n, 'handleRemoveHotKey')(e, n)\n        .then(() => removeCell(focus))\n        .catch(falser)\n    },\n\n    // focus next cell\n    focusNext: (e: Event) => {\n      if (!isEditMode) {\n        return\n      }\n\n      const n = node(focus, id)\n      hotKeyHandler(n, 'handleFocusNextHotKey')(e, n)\n        .then(() => {\n          const found = nextLeaf(editable.cellOrder, focus)\n          if (found) {\n            blurAllCells()\n            focusCell(found.id)\n          }\n        })\n        .catch(falser)\n    },\n\n    // focus previous cell\n    focusPrev: (e: Event) => {\n      if (!isEditMode) {\n        return\n      }\n\n      const n = node(focus, id)\n      hotKeyHandler(n, 'handleFocusPreviousHotKey')(e, n)\n        .then(() => {\n          const found = previousLeaf(editable.cellOrder, focus)\n          if (found) {\n            blurAllCells()\n            focusCell(found.id)\n          }\n        })\n        .catch(falser)\n    }\n  })\n}\n\nconst Decorator = (props: Props) => (\n  <HotKeys handlers={handlers(props)} style={{ outline: 'none' }}>\n    {props.children}\n  </HotKeys>\n)\n\nconst mapStateToProps = createStructuredSelector({\n  isEditMode, focus,\n  node: (state: any) => (id: string, editable: string) => node(state, { id, editable }),\n  editable: (state: any, props: any) => editable(state, props),\n})\n\nconst mapDispatchToProps = {\n  undo,\n  redo,\n  removeCell,\n  focusCell: (id: string) => focusCell(id)(),\n  blurAllCells\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Decorator)\n"]}